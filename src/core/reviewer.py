# src/core/reviewer.py
import time
import threading
from pathlib import Path
import rerun as rr
import rerun.blueprint as rrb
from pynput import keyboard  # å¼•å…¥é”®ç›˜ç›‘å¬åº“
from src.core.factory import ReaderFactory

class DatasetReviewer:
    def __init__(self, visualizer):
        """
        :param visualizer: RerunVisualizer å®ä¾‹
        """
        self.viz = visualizer
        self.bad_datasets = [] 
        self.current_idx = 0
        self.dataset_paths = []
        self.is_running = False
        self.needs_refresh = False # æ ‡è®°æ˜¯å¦éœ€è¦åˆ·æ–°ç”»é¢

    def start_review(self, dataset_paths: list):
        """
        å¯åŠ¨äº¤äº’å¼å®¡æ ¸æµç¨‹ (å…¨å±€é”®ç›˜ç›‘å¬ç‰ˆ)
        """
        if not dataset_paths:
            print("âŒ æ²¡æœ‰æ•°æ®å¯å®¡æ ¸")
            return []

        self.dataset_paths = dataset_paths
        self.current_idx = 0
        self.is_running = True
        self.needs_refresh = True # åˆå§‹åˆ·æ–°

        print("\n" + "="*50)
        print("ğŸ•µï¸â€â™‚ï¸ è¿›å…¥äº¤äº’å¼å®¡æ ¸æ¨¡å¼ (é”®ç›˜æ§åˆ¶)")
        print("="*50)
        print("ä¿æŒ Rerun çª—å£åœ¨å‰å°å³å¯ï¼Œä½¿ç”¨ä»¥ä¸‹æŒ‰é”®æ§åˆ¶ï¼š")
        print("  [â†’] å³ç®­å¤´ / N : ä¸‹ä¸€ä¸ªæ•°æ®")
        print("  [â†] å·¦ç®­å¤´ / P : ä¸Šä¸€ä¸ªæ•°æ®")
        print("  B / b    : æ ‡è®°/å–æ¶ˆæ ‡è®°ã€å¼‚å¸¸ã€‘")
        print("  [Esc] / Q      : é€€å‡ºå®¡æ ¸")
        print("-" * 50)

        # 1. è®¾ç½®å¸ƒå±€
        self._setup_review_layout()

        # 2. å¯åŠ¨é”®ç›˜ç›‘å¬ (éé˜»å¡)
        listener = keyboard.Listener(on_release=self._on_key_release)
        listener.start()

        # 3. ä¸»å¾ªç¯ (ä»£æ›¿åŸæ¥çš„ input é˜»å¡)
        try:
            while self.is_running:
                if self.needs_refresh:
                    self._refresh_view()
                    self.needs_refresh = False
                
                # é™ä½ CPU å ç”¨ï¼Œè½®è¯¢é¢‘ç‡ 10Hz è¶³å¤Ÿäº†
                time.sleep(0.1)
                
        except KeyboardInterrupt:
            pass
        finally:
            listener.stop()

        return self.bad_datasets

    def _on_key_release(self, key):
        """
        é”®ç›˜å›è°ƒå‡½æ•° (è¿è¡Œåœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­)
        """
        if not self.is_running:
            return False # åœæ­¢ç›‘å¬

        try:
            # è·å–é”®å€¼
            k = None
            if hasattr(key, 'char'):
                k = key.char  # å­—æ¯é”®
            else:
                k = key       # ç‰¹æ®Šé”® (Key.right, Key.esc)

            # é€»è¾‘æ˜ å°„
            if k == 'q' or k == keyboard.Key.esc:
                print("\nâ¹ é€€å‡ºå®¡æ ¸...")
                self.is_running = False
                return False
            
            elif k == 'n' or k == keyboard.Key.right:
                if self.current_idx < len(self.dataset_paths) - 1:
                    self.current_idx += 1
                    self.needs_refresh = True
                else:
                    print("\nğŸ‰ å·²ç»æ˜¯æœ€åä¸€ä¸ªäº†ï¼(æŒ‰ Q é€€å‡º)")

            elif k == 'p' or k == keyboard.Key.left:
                if self.current_idx > 0:
                    self.current_idx -= 1
                    self.needs_refresh = True
                else:
                    print("\nå·²ç»æ˜¯ç¬¬ä¸€ä¸ªäº†ï¼")

            elif k == 'b':
                self._toggle_bad_mark()
                self.needs_refresh = True

        except Exception as e:
            print(f"Key Error: {e}")

    def _toggle_bad_mark(self):
        path = self.dataset_paths[self.current_idx]
        name = Path(path).name
        if path not in self.bad_datasets:
            self.bad_datasets.append(path)
            print(f"âš ï¸ [æ ‡è®°å¼‚å¸¸]: {name}")
        else:
            self.bad_datasets.remove(path)
            print(f"ğŸ‘Œ [å–æ¶ˆæ ‡è®°]: {name}")

    def _refresh_view(self):
        """
        åˆ·æ–°å½“å‰æ•°æ®çš„ç”»é¢
        """
        path = self.dataset_paths[self.current_idx]
        name = Path(path).name
        
        # ç»ˆç«¯æ‰“å°è¿›åº¦ (è¦†ç›–å¼æ‰“å°ï¼Œé˜²æ­¢åˆ·å±)
        status_icon = "âŒ BAD" if path in self.bad_datasets else "âœ… OK"
        print(f"\r[{self.current_idx+1}/{len(self.dataset_paths)}] å®¡æ ¸ä¸­: {name} | çŠ¶æ€: {status_icon}    ", end="", flush=True)

        self._show_dataset_snapshot(path)

    def _setup_review_layout(self):
        """
        è®¾ç½® Rerun å¸ƒå±€ï¼šå¼ºåˆ¶æ˜¾ç¤º 3 åˆ—
        """
        blueprint = rrb.Blueprint(
            rrb.Vertical(
                rrb.TextDocumentView(origin="review/info", name="Dataset Info"),
                rrb.Horizontal(
                    rrb.Spatial2DView(origin="review/0_start", name="Start (0%)"),
                    rrb.Spatial2DView(origin="review/1_mid", name="Mid (50%)"),
                    rrb.Spatial2DView(origin="review/2_end", name="End (100%)"),
                ),
                row_shares=[1, 4]
            ),
            collapse_panels=True
        )
        rr.send_blueprint(blueprint)

    def _show_dataset_snapshot(self, path: str):
        """
        æå– 3 å¸§å¹¶æ˜¾ç¤º
        """
        rr.log("review", rr.Clear(recursive=True))

        try:
            reader = ReaderFactory.get_reader(path)
            if not reader.load(path):
                rr.log("review/info", rr.TextDocument(f"âŒ Load Failed: {Path(path).name}"))
                return

            length = reader.get_length()
            if length == 0:
                rr.log("review/info", rr.TextDocument(f"âš ï¸ Empty Dataset"))
                return

            indices = {
                "0_start": 0,
                "1_mid": length // 2,
                "2_end": length - 1
            }

            # åŠ¨æ€æ›´æ–° Info é¢æ¿
            status_text = "ğŸ”´ **BAD DATA**" if path in self.bad_datasets else "ğŸŸ¢ **GOOD DATA**"
            info_text = f"# {Path(path).name}\n\n"
            info_text += f"**Frames**: {length}\n"
            info_text += f"**Type**: {type(reader).__name__}\n"
            info_text += f"**Status**: {status_text}\n"
            info_text += "\n---\n**Controls**:\n[â†’] Next | [â†] Prev | [Space] Mark Bad | [Esc] Quit"
            
            rr.log("review/info", rr.TextDocument(info_text, media_type="text/markdown"))

            for prefix, idx in indices.items():
                frame = reader.get_frame(idx)
                for cam_name, img in frame.images.items():
                    rr.log(f"review/{prefix}/{cam_name}", rr.Image(img))
            
            reader.close()

        except Exception as e:
            # print(f"\nError reviewing {path}: {e}")
            pass